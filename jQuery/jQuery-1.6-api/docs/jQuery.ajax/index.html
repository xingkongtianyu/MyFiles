<!DOCTYPE html>
<html lang='en'>
<head>
<meta http-equiv='content-type' content='text/html; charset=UTF-8' /><title>jQuery 1.6  API 中文版 -- 前端攻城师</title>
</head>
<body>
<div class="entry-content">
  <div class="entry-title roundTop">
    <h1 class="jq-clearfix">jQuery.ajax()</h1>
    <div class="entry-meta jq-clearfix"> Categories: <span class="category"><a   target="_blank" href="http://api.jquery.com/category/ajax/" title="View all posts in Ajax">Ajax</a> &gt; <a   target="_blank" href="http://api.jquery.com/category/ajax/low-level-interface/" title="View all posts in Low-Level Interface">Low-Level Interface</a></span> </div>
  </div>
  <div id="jQuery-ajax1" class="entry method">
    <h2 class="jq-clearfix roundTop section-title"> <span class="name">jQuery.ajax( url, [ settings ] )</span> <span class="returns">返回: <a class="return"   target="_blank" href="http://api.jquery.com/Types/#jqXHR">jqXHR</a></span> </h2>
    <div class="jq-box roundBottom entry-details">
      <p class="desc"><strong>描述: </strong>执行一个异步的HTTP（Ajax）的请求。</p>
      <ul class="signatures">
        <li class="signature" id="jQuery-ajax-url-settings">
          <h4 class="name"> <span class="versionAdded">version added: <a href="/category/version/1.5/">1.5</a></span>jQuery.ajax( url, [ settings ] )</h4>
          <p class="arguement"><strong>url</strong>一个用来包含发送请求的URL字符串。</p>
          <p class="arguement"><strong>settings</strong>一个以"{键:值}"组成的AJAX 请求设置。所有选项都是可选的。可以使用<a href="#p=jQuery.ajaxSetup">$.ajaxSetup()</a>设置任何默认参数。看<a href="#jQuery-ajax-settings">jQuery.ajax( settings )</a>下所有设置的完整列表。</p>
        </li>
        <li class="signature" id="jQuery-ajax-settings">
          <h4 class="name"> <span class="versionAdded">version added: <a href="/category/version/1.0/">1.0</a></span>jQuery.ajax( settings )</h4>
          <p class="arguement"><strong>settings</strong>一个以"{键:值}"组成的AJAX 请求设置。所有选项都是可选的。可以使用<a href="#p=jQuery.ajaxSetup">$.ajaxSetup()</a>设置任何默认参数。</p>
          <div class="options">
            <h5 class="option">accepts<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Map">Map</a></span> </h5>
            <div class="default-value"> <strong>默认： </strong>取决于数据类型</div>
            <p>内容类型发送请求头，告诉服务器什么样的响应会接受返回。如果<code>accepts</code>设置需要修改，推荐在<code>$.ajaxSetup()</code>方法中做一次。</p>
            <h5 class="option">async<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Boolean">Boolean</a></span> </h5>
            <div class="default-value"> <strong>默认： </strong>true</div>
            <p>默认设置下，所有请求均为异步请求（也就是说这是默认设置为<code>true</code>）。如果需要发送同步请求，请将此选项设置为 <code>false</code>。跨域请求和<code>dataType: "jsonp"</code>请求不支持同步操作。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。</p>
            <h5 class="option">beforeSend(jqXHR, settings)<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Function">Function</a></span> </h5>
            <p>发送请求前可修改 jqXHR（在jQuery 1.4.x的中，XMLHttpRequest） 对象的函数，如添加自定义 HTTP 头等。该jqXHR和设置作为参数传递的。这是一个<a href="http://docs.jquery.com/Ajax_Events">Ajax事件</a> 。<code>beforeSend</code>行数返回的<code>false</code>将取消该请求。<strong>在jQuery 1.5，</strong> <code>beforeSend</code>选项将被访问，不管请求的类型。</p>
            <h5 class="option">cache<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Boolean">Boolean</a></span> </h5>
            <div class="default-value"> <strong>默认： </strong>true, dataType为&quot;script&quot;和&quot;jsonp&quot;时默认为false</div>
            <p>如果设置为 false   ，浏览器将不缓存此页面。</p>
            <h5 class="option">complete(jqXHR, textStatus)<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Function,%20Array">Function, Array</a></span> </h5>
            <p>请求完成后回调函数 (请求成功或失败之后均调用)。这个回调函数得到2个参数： jqXHR (in jQuery 1.4.x, XMLHTTPRequest) 对象和一个描述成功请求类型的字符串("success", "notmodified", "error","timeout", or "parsererror") 。<strong>在jQuery 1.5，</strong> <code>complete</code>设置可以接受一个函数的数组。每个函数将被依次调用。这是一个<a href="http://docs.jquery.com/Ajax_Events">Ajax事件</a> 。 </p>
            <h5 class="option">contents<span class="added">(added 1.5)</span><span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Map">Map</a></span> </h5>
            <p>一个以"{字符串:正则表达式}"配对的对象，用来确定jQuery将如何解析响应，给定其内容类型。</p>
            <h5 class="option">contentType<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#String">String</a></span> </h5>
            <div class="default-value"> <strong>默认: </strong>'application/x-www-form-urlencoded'</div>
            <p>发送信息至服务器时内容编码类型。默认值是"application/x-www-form-urlencoded"，适合大多数情况。如果你明确地传递了一个content-type给 $.ajax()   那么他必定会发送给服务器（即使没有数据要发送）。数据将总是使用UTF-8字符集传递给服务器；你必须译码这适当的在服务器端。</p>
            <h5 class="option">context<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Object">Object</a></span> </h5>
            <p>这个对象用于设置Ajax相关回调函数的上下文。也就是说，让回调函数内this指向这个对象（如果不设定这个参数，那么this就指向调用本次AJAX请求时传递的options参数）。比如指定一个DOM元素作为context参数，这样就设置了success回调函数的上下文为这个DOM元素。就像这样： </p>
            <pre>$.ajax({
  url: "test.html",
  context: document.body,
  success: function(){
    $(this).addClass("done");
  }
});</pre>
            <h5 class="option">converters<span class="added">(1.5新增)</span><span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Map">Map</a></span> </h5>
            <div class="default-value"> <strong>默认： </strong>{"* text": window.String, "text html": true, "text json": jQuery.parseJSON, "text xml": jQuery.parseXML}</div>
            <p>一个数据类型对数据类型转换器的对象。每个转换器的值是一个函数，返回响应的转化值</p>
            <h5 class="option">crossDomain<span class="added">(1.5新增)</span><span class="type"><a   target="_blank" href="http://api.jquery.com/Types#"></a></span> </h5>
            <div class="default-value"> <strong>默认： </strong>同域请求为false， 跨域请求为true</div>
            <p>如果你想强制跨域请求（如JSONP形式）同一域，设置crossDomain为<code>true</code>。这使得例如，服务器端重定向到另一个域</p>
            <h5 class="option">data<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Object,%20String">Object, String</a></span> </h5>
            <p>发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为"{键:值}"格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:["bar1", "bar2"]} 转换为   '&amp;foo=bar1&amp;foo=bar2'。 如果值是一个数组（ Array ）, jQuery将在 多个连续的值具有相同的键值的基础上建立的传统设置(下述)。 </p>
            <h5 class="option">dataFilter(data, type)<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Function">Function</a></span> </h5>
            <p>一个函数被用来处理XMLHttpRequest的原始响应数据。这是一个预过滤功能，净化响应。您应该返回安全数据。提供data和type两个参数：data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。</p>
            <h5 class="option">dataType<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#String">String</a></span> </h5>
            <div class="default-value"> <strong>默认: </strong>Intelligent Guess (xml, json, script, or html)</div>
            <p>预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，比如XML   MIME类型就被识别为XML。在1.4中，JSON就会生成一个JavaScript对象，而script则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。可用值: </p>
            <ul>
              <li>"xml": 返回 XML 文档，可用 jQuery 处理。.</li>
              <li>"html": 返回纯文本 HTML 信息；包含的script标签会在插入dom时执行。</li>
              <li>"script": 评估为JavaScript并返回纯文本响应。不会自动缓存结果。除非设置了"cache"参数。'''注意：'''在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(因为将使用DOM的script标签来加载)</li>
              <li>"json": 评估为JSON响应，并返回一个JavaScript对象。1.4中，JSON就会生成一个JavaScript对象，而script则会执行这个脚本。（见<a href="http://json.org/">json.org</a>的更多信息，正确的JSON格式。）
</li>
              <li>"jsonp": <a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/">JSONP</a> 格式。使用<a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/">JSONP</a> 形式调用函数时，如 "myurl?callback=?" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。</li>
              <li>"text":  返回纯文本字符串。</li>
              <li>多个空格分割的值:<strong>As of jQuery 1.5</strong>，  jQuery可以从Content - Type头收到并转换一个您需要的数据类型。例如，如果你想要一个文本响应为XML处理，使用"text xml"数据类型。您也可以将一个JSONP的请求，以文本形式接受，并用jQuery以XML解析: "jsonp text xml"。同样地可以使用"jsonp xml"简写,将首先尝试从JSONP形式转换为XML,做不到这一点，并没有从文本，从JSONP形式转换为文本，然后到XML。</li>
            </ul>
            <h5 class="option">error(jqXHR, textStatus, errorThrown)<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Function">Function</a></span> </h5>
            <p>请求失败时调用此函数。有以下三个参数：jqXHR (在 jQuery 1.4.x中, XMLHttpRequest)   对象、描述发生的错误类型的一个字符串和捕获的异常对象。如果发生了错误，错误信息（第二个参数）除了得到<code>null</code>之外，还可能是<code>"timeout"</code>, <code>"error"</code>, <code>"abort"</code> 和 <code>"parsererror"</code>。这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax Event</a>。 <strong>在jQuery 1.5</strong>, 在<code>error</code>设置可以接受函数组成的数组。每个函数将被依次调用。 <strong>注意：</strong><em>此处理程序不被跨域脚本和JSONP形式的请求调用。</em></p>

            <h5 class="option">global<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Boolean">Boolean</a></span> </h5>
            <div class="default-value"> <strong>默认: </strong>true</div>
            <p>无论怎么样这个请求将触发全局AJAX事件处理程序。默认是<code>true</code> 。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 可用于控制不同的。这可以用来控制各种<a href="http://docs.jquery.com/Ajax_Events">Ajax Events</a>.</p>

            <h5 class="option">headers<span class="added">(1.5新增)</span><span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Map">Map</a></span> </h5>
            <div class="default-value"> <strong>Default: </strong>{}</div>
            <p>一个额外的"{键:值}"对映射到请求一起发送。此设置被设置之前<code>beforeSend</code>函数被调用;因此，消息头中的值设置可以在覆盖<code>beforeSend</code>函数范围内的任何设置。</p>

            <h5 class="option">ifModified<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Boolean">Boolean</a></span> </h5>
            <div class="default-value"> <strong>默认: </strong>false</div>
            <p>仅在服务器数据改变时获取新数据。使用 HTTP 包 Last-Modified 头信息判断。在jQuery   1.4中，他也会检查服务器指定的'etag'来确定数据没有被修改过。</p>

						<h5 class="option">isLocal<span class="added">(added 1.5.1)</span><span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Boolean">Boolean</a></span>
						</h5>
						<div class="default-value">
						<strong>默认: </strong>取决于当前的位置协议</div>
						<p>允许当前环境被认定为“本地”，（如文件系统），即使jQuery默认情况下不会承认它。以下协议目前公认为本地：<code>file</code>, <code>*-extension</code>, and <code>widget</code>。如果<code>isLocal</code>设置需要修改，建议在<code>$.ajaxSetup()</code>方法中这样做一次。</p>

            <h5 class="option">jsonp<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#String">String</a></span> </h5>
            <p>在一个jsonp请求中重写回调函数的名字。这个值用来替代在"callback=?"这种GET或POST请求中URL参数里的"callback"部分，比如{jsonp:'onJsonPLoad'}会导致将"onJsonPLoad=?"传给服务器。<strong>在jQuery 1.5，</strong>，设置<code>jsonp</code>选项为<code>false</code>阻止了jQuery从加入"?callback"字符串的URL或试图使用"=?"转换。在这种情况下，你也应该明确设置<code>jsonpCallback</code>设置。例如, <code>{ jsonp: false, jsonpCallback: "callbackName" }</code></p>

            <h5 class="option">jsonpCallback<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#String,%20Function">String, Function</a></span> </h5>
            <p>为jsonp请求指定一个回调函数名。这个值将用来取代jQuery自动生成的随机函数名。这主要用来让jQuery生成度独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存GET请求的时候，指定这个回调函数名。<strong>在jQuery 1.5，</strong>你也可以使用一个函数值该设置，在这种情况下<code>jsonpCallback</code>的值设置到该函数的返回值。</p>
						
						<h5 class="option">mimeType<span class="added">(added 1.5.1)</span><span class="type"><a   target="_blank" href="http://api.jquery.com/Types#String">String</a></span>
						</h5>
						<p>一个mime类型用来覆盖<abbr title="XMLHttpRequest的">XHR的</abbr> MIME类型。</p>

            <h5 class="option">password<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#String">String</a></span> </h5>
            <p>用于响应HTTP访问认证请求的密码</p>

            <h5 class="option">processData<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Boolean">Boolean</a></span> </h5>
            <div class="default-value"> <strong>默认: </strong>true</div>
            <p>默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型   "application/x-www-form-urlencoded"。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 <code>false</code>。</p>

            <h5 class="option">scriptCharset<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#String">String</a></span> </h5>
            <p>只有当请求时dataType为"jsonp"或"script"，并且type是"GET"才会用于强制修改charset。通常只在本地和远程的内容编码不同时使用。</p>

            <h5 class="option">statusCode<span class="added">(1.5新增)</span><span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Map">Map</a></span> </h5>
            <div class="default-value"> <strong>默认: </strong>{}</div>
            <p>一组数值的HTTP代码和函数对象，当响应时调用了相应的代码。例如，如果响应状态是404，将触发以下警报：</p>
            <pre>$.ajax({
  statusCode: {404: function() {
    alert('page not found');
  }
});</pre>
            <p>如果请求成功，状态代码函数作为回调的成功相同的参数;如果在一个错误的结果，他们采取了相同的参数<code>error</code>回调。</p>

            <h5 class="option">success(data, textStatus, jqXHR)<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Function,%20Array">Function, Array</a></span> </h5>
            <p>请求成功后的回调函数。这个函数传递3个参数：从服务器返回的数据，并根据dataType参数进行处理后的数据，一个描述状态的字符串;还有 jqXHR（在jQuery 1.4.x的中，XMLHttpRequest） 对象 。<strong>在jQuery 1.5，</strong> <em>成功设置可以接受一个函数数组。每个函数将被依次调用。</em>这是一个 <a href="http://docs.jquery.com/Ajax_Events">Ajax Event</a>.</p>


            <h5 class="option">timeout<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Number">Number</a></span> </h5>
            <p>设置请求超时时间（毫秒）。如果一个设置有<a   target="_blank" href="http://api.jquery.com/jQuery.ajaxSetup">$.ajaxSetup()</a>，此设置将覆盖全局设置。例如，你可以使用这个属性来提供一个单一的请求比所有你所设置时间在一秒钟内的其他要求更长的超时。见<a   target="_blank" href="http://api.jquery.com/jQuery.ajaxSetup"><code>$.ajaxSetup()</code></a>全局超时。</p>

            <h5 class="option">traditional<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Boolean">Boolean</a></span> </h5>
            <p>如果你想要用传统的方式来序列化数据，那么就设置为true。请参考工具分类下面的<a href="#p=jQuery.param">jQuery.param </a>方法.</p>

            <h5 class="option">type<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#String">String</a></span> </h5>
            <div class="default-value"> <strong>默认: </strong>'GET'</div>
            <p>请求方式 ("POST" 或 "GET")， 默认为 "GET"。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。</p>

            <h5 class="option">url<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#String">String</a></span> </h5>
            <div class="default-value"> <strong>默认: </strong>当前地址</div>
            <p>发送请求的地址。</p>

            <h5 class="option">username<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#String">String</a></span> </h5>
            <p>于响应HTTP访问认证请求的用户名</p>

            <h5 class="option">xhr<span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Function">Function</a></span> </h5>
            <div class="default-value"> <strong>默认 </strong>当可用的ActiveXObject（IE）中，否则为XMLHttpRequest</div>
            <p>回调创建XMLHttpRequest对象。当可用时默认为ActiveXObject（IE）中，否则为XMLHttpRequest。提供覆盖你自己的执行的XMLHttpRequest或增强工厂。</p>

						<h5 class="option">xhrFields<span class="added">(added 1.5.1)</span><span class="type"><a   target="_blank" href="http://api.jquery.com/Types#Map">Map</a></span>
						</h5>
						<p>一对“文件名-文件值”在本机设置<code><abbr title="XMLHttpRequest">XHR</abbr></code>对象。例如，如果需要的话，你可以用它来设置<code>withCredentials</code>为<code>true</code>的跨域请求。</p>
          </div>
        </li>
      </ul>
      <div class="longdesc">
        <p><code>$.ajax()</code>函数所有的基础jQuery的Ajax请求发送。它往往不是必须的，直接调用这个函数，几个高层次的替代品如<a href="/jQuery.get"><code>$.get()</code></a>和<a href="/load"><code>.load()</code></a>可用，更容易使用，如果不常见的选项是必需的，不过， <code>$.ajax()</code>可以使用更灵活。</p>
        <p>在简单地说， <code>$.ajax()</code>函数可以不带参数调用：</p>
        <pre>$.ajax();</pre>
        <p><strong>注意:</strong> 所有的选项都可以通过<code><a href="#p=jQuery.ajaxSetup">$.ajaxSetup()</a></code> 函数来全局设置</p>
        <p>这个例子中，不使用选项，加载当前页面的内容，但其结果没有。若要使用结果，我们可以实现的回调功能之一。 </p>
        <h4 id="jqXHR">jqXHR 对象</h4>
        <p> 该jQuery的XMLHttpRequest（jqXHR）对象返回<code>$.ajax()</code> <strong>在jQuery 1.5</strong>是一个对象的超集浏览器的原生的XMLHttpRequest。例如，它包含<code>responseText</code>和<code>responseXML</code>性能，以及一个<code>getResponseHeader()</code>方法。当传输机制是XMLHttpRequest以外的东西（例如，一个一个JSONP请求脚本标签）的jqXHR对象尽可能的模拟原生的XHR功能。 </p>
				<p><strong>在jQuery 1.5.1</strong>， 在<code>jqXHR</code>对象还包含了<code>overrideMimeType</code>方法。 </p>
        <p><code>$.ajax()</code>返回的jqXHR对象 实现约定的接口，给他们的所有属性，方法，和约定的行为（见<a   target="_blank" href="http://api.jquery.com/category/deferred-object/">Deferred object</a>获取更多信息）。为了方便和一致性<code>$.ajax()</code>回调函数名称中使用。jqXHR也提供<code>.error()</code> <code>.success()</code>和<code>.complete()</code>方法。这些方法当<code>$.ajax()</code>请求终止时需要一个函数参数调用，这个函数接收<code>$.ajax()</code>回调函数名相同的参数。在jQuery 1.5这允许你指定一个请求的多个回调，甚至可能分配请求后已完成回调。（如果请求已经完成，回调立即触发。）</p>
        <pre>// Assign handlers immediately after making the request,
// and remember the jqxhr object for this request
var jqxhr = $.ajax({ url: "example.php" })
    .success(function() { alert("success"); })
    .error(function() { alert("error"); })
    .complete(function() { alert("complete"); });

// perform other work here ...

// Set another completion function for the request above
jqxhr.complete(function(){ alert("second complete"); });</pre>
        <p>为了向后兼容<code>XMLHttpRequest</code> ，一<code>jqXHR</code>对象将公开下列属性和方法：</p>
        <ul>
          <li><code>readyState</code></li>
          <li><code>status</code></li>
          <li><code>statusText</code></li>
          <li> <code>responseXML</code> and/or <code>responseText</code> 当底层的请求分别作出XML和/或文本响应</li>
          <li> <code>setRequestHeader(name, value)</code> 这背离了换上了新一旧的价值，而不是串联的新值与旧标准 </li>
          <li><code>getAllResponseHeaders()</code></li>
          <li><code>getResponseHeader()</code></li>
          <li><code>abort()</code></li>
        </ul>
        <p>假如没有<code>onreadystatechange</code>机制，不管怎样
          由于<code>success</code> ， <code>error</code> ， <code>complete</code>和<code>statusCode</code>覆盖所有可能的要求。</p>
        <h4 id="callback-functions">回调函数</h4>
        <p>如果要处理$.ajax()得到的数据，则需要使用回调函数。beforeSend、error、dataFilter、success、complete。 </p>
        <p><strong>在jQuery 1.5，</strong> <code>error</code> ， <code>success</code> ，和<code>complete</code>回调钩子先入先出队列管理。这意味着你可以为每个挂钩分配多个回调。见<a   target="_blank" href="http://api.jquery.com/category/deferred-object/">Deferred object methods</a> ，这是实现内部的<code>$.ajax()</code>回调挂钩。</p>
        <p>在<code>this</code>回调是在所有参考对象在<code>context</code>选项传递给<code>$.ajax</code>在设置;如果<code>context</code>没有指定， <code>this</code>是他们自己的Ajax设置参考。</p>
        <p>某些类型Ajax的请求，如JSONP形式和跨域的GET请求，请不要使用XHR;在这些情况下<code>XMLHttpRequest</code>和<code>textStatus</code>参数传递给回调是<code>undefined</code> 。</p>
        <p>这里有<code>$.ajax()</code>提供的钩子回调 ：</p>
        <ol>
          <LI>beforeSend 在发送请求之前调用，它接收<code>jqXHR</code>对象和<code>settings</code>作为参数对象。</LI>
          <LI>error 在请求出错时调用。如果请求失败，在它们的顺序依次登记。他们收到<code>jqXHR</code> ，字符串表示的错误类型，如果适用的异常对象。一些内置的错误，将提供作为例外对象的字符串： "abort", "timeout", "No Transport"。</LI>
          <LI><code>dataFilter</code> 在请求成功之后调用。传入返回的数据以及<code>dataType</code>参数的值。并且必须返回新的数据（可能是处理过的）传递给<code>success</code>回调函数。</LI>
          <LI><code>success</code> 当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。他们收到返回的数据，一个包含成功的代码和<code>jqXHR</code>对象。 </LI>
          <LI><code>complete</code> 它们的顺序依次登记回调，请求完成时，无论是在失败或成功。他们收到<code>jqXHR</code>对象，以及一个包含成功或错误代码。</LI>
        </ol>
        <p>For example, 通过使用返回的HTML，我们可以实现一个<code>success</code>事件处理器：</p>
        <pre>$.ajax({
  url: 'ajax/test.html',
  success: function(data) {
    $('.result').html(data);
    alert('Load was performed.');
  }
});</pre>
        <h4 id="data-types">数据类型</h4>
        <p>$.ajax()函数依赖服务器提供的信息来处理返回的数据。如果服务器报告说返回的数据是XML，那么返回的结果就可以用普通的XML方法或者jQuery的选择器来遍历。如果见得到其他类型，比如HTML，则数据就以文本形式来对待。 </p>
        <p>通过dataType选项还可以指定其他不同数据处理方式。除了单纯的XML，还可以指定 html、json、jsonp、script或者text。 </p>
        <p>其中，text和xml类型返回的数据不会经过处理。这些数据仅仅是传递给处理程序的成功，无论是通过<code>responseText</code>或<code>responseXML</code>所有的<code>jqXHR</code>对象。</p>
        <p><strong>注意:</strong>我们必须确保网页服务器报告的MIME类型与我们选择的dataType所匹配。比如说，XML的话，服务器端就必须声明 <code>text/xml</code> 或者 <code>application/xml</code> 来获得一致的结果。 </p>
        <p>如果指定为 <code>html</code>类型，任何内嵌的JavaScript都会在HTML作为一个字符串返回之前执行。类似的，指定<code>script</code>类型的话，也会先执行服务器端生成JavaScript，然后再把脚本作为一个文本数据返回。</p>
        <p>如果指定为<code>json</code>类型，则会把获取到的数据作为一个JavaScript对象来解析，并且把构建好的对象作为结果返回。为了实现这个目的，他首先尝试使用<code>jQuery.parseJSON()</code>。如果浏览器不支持，则使用一个<code>Function</code>来<strong>构建</strong>。JSON数据是一种能很方便通过JavaScript解析的结构化数据。如果获取的数据文件存放在远程服务器上（域名不同，也就是跨域获取数据），则需要使用jsonp类型。使用这种类型的话，会创建一个查询字符串参数 <code>callback=?</code> ，这个参数会加在请求的URL后面。服务器端应当在JSON数据前加上回调函数名，以便完成一个有效的JSONP请求。如果要指定回调函数的参数名来取代默认的callback，可以通过设置<code>$.ajax()</code>的jsonp参数。 </p>
        <p><strong>注意:</strong>JSONP是JSON格式的扩展。他要求一些服务器端的代码来检测并处理查询字符串参数。更多信息可以参阅<a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/">original post detailing its use</a>.</p>
        <p>如果指定了<code>script</code>或者<code>jsonp</code>类型，那么当从服务器接收到数据时，实际上是用了&lt;script&gt;标签而不是XMLHttpRequest对象。这种情况下，$.ajax()不再返回一个XMLHttpRequest对象，并且也不会传递事件处理函数，比如beforeSend。 </p>
        <h4 id="sending-data-to-server">发送数据到服务器</h4>
        <p>默认情况下，Ajax请求使用GET方法。如果要使用POST方法，可以设定<code>type</code>参数值。这个选项也会影响data选项中的内容如何发送到服务器。 </p>
        <p>data选项既可以包含一个查询字符串，比如 key1=value1&amp;key2=value2 ，也可以是一个映射，比如 {key1:   'value1', key2: 'value2'}   。如果使用了后者的形式，则数据再发送器会被转换成查询字符串。这个处理过程也可以通过设置processData选项为false来回避。如果我们希望发送一个XML对象给服务器时，这种处理可能并不合适。并且在这种情况下，我们也应当改变contentType选项的值，用其他合适的MIME类型来取代默认的   application/x-www-form-urlencoded 。 </p>
        <h4 id="advanced-options"><STRONG>高级选项</STRONG></h4>
        <p>global选项用于阻止响应注册的回调函数，比如.ajaxSend，或者ajaxError，以及类似的方法。这在有些时候很有用，比如发送的请求非常频繁且简短的时候，就可以在ajaxSend里禁用这个。更多关于这些方法的详细信息，请参阅下面的内容。 </p>
        <p>如果服务器需要HTTP认证，可以使用用户名和密码可以通过username和password选项来设置。 </p>
        <p>Ajax请求是限时的，所以错误警告被捕获并处理后，可以用来提升用户体验。请求超时这个参数通常就保留其默认值，要不就通过jQuery.ajaxSetup来全局设定，很少为特定的请求重新设置timeout选项。 </p>
        <p>默认情况下，请求总会被发出去，但浏览器有可能从他的缓存中调取数据。要禁止使用缓存的结果，可以设置cache参数为false。如果希望判断数据自从上次请求后没有更改过就报告出错的话，可以设置ifModified为true。 </p>
        <p>scriptCharset允许给&lt;script&gt;标签的请求设定一个特定的字符集，用于script或者jsonp类似的数据。当脚本和页面字符集不同时，这特别好用。 </p>
        <p>Ajax的第一个字母是asynchronous的开头字母，这意味着所有的操作都是并行的，完成的顺序没有前后关系。$.ajax()的async参数总是设置成true，这标志着在请求开始后，其他代码依然能够执行。强烈不建议把这个选项设置成false，这意味着所有的请求都不再是异步的了，这也会导致浏览器被锁死。 </p>
        <p>$.ajax函数返回他创建的XMLHttpRequest对象。通常jQuery只在内部处理并创建这个对象，但用户也可以通过xhr选项来传递一个自己创建的xhr对象。返回的对象通常已经被丢弃了，但依然提供一个底层接口来观察和操控请求。比如说，调用对象上的.abort()可以在请求完成前挂起请求。</p>
        <h4>扩展的Ajax</h4>
        <p><strong>在jQuery 1.5，</strong>，jQuery的Ajax实现包括预过滤器，转换器和传输，让您扩展了很大的灵活性Ajax。如需有关这些先进功能的信息，请参阅<a   target="_blank" href="http://api.jquery.com/extending-ajax/">Extending Ajax</a></p>
      </div>
      <h3 id="notes-0">其他注意事项：</h3>
      <div class="longdesc">
        <ul>
          <li> 由于浏览器的安全限制，大多数“Ajax”的要求，均采用<a title="维基百科上的同源策略" href="http://en.wikipedia.org/wiki/Same_origin_policy">同一起源的政策</a> ;该请求不能成功地检索来自不同的域，子域或协议的数据。</li>
          <li>Script和JSONP形式请求不受同源策略的限制。</li>
        </ul>
      </div>
      <h3>Examples:</h3>
      <div class="entry-examples" id="entry-examples">
        <div id="example-0">
          <h4>Example: <span class="desc">加载并执行一个 JS 文件。</span> </h4>
          <pre><code class="example">$.ajax({
   type: "GET",
   url: "test.js",
   dataType: "script"
 });</code></pre>
        </div>
        <div id="example-1">
          <h4>Example: <span class="desc">保存数据到服务器，成功时显示信息。</span> </h4>
          <pre><code class="example">$.ajax({
   type: "POST",
   url: "some.php",
   data: "name=John&amp;location=Boston",
   success: function(msg){
     alert( "Data Saved: " + msg );
   }
 });</code></pre>
        </div>
        <div id="example-2">
          <h4>Example: <span class="desc">装入一个 HTML 网页最新版本。</span> </h4>
          <pre><code class="example">$.ajax({
  url: "test.html",
  cache: false,
  success: function(html){
    $("#results").append(html);
  }
});</code></pre>
        </div>
        <div id="example-3">
          <h4>Example: <span class="desc">同步加载数据。发送请求时锁住浏览器。需要锁定用户交互操作时使用同步方式。</span> </h4>
          <pre><code class="example">var html = $.ajax({
  url: "some.php",
  async: false
 }).responseText;</code></pre>
        </div>
        <div id="example-4">
          <h4>Example: <span class="desc">发送 XML 数据至服务器。设置 processData 选项为 false，防止自动转换数据格式。</span> </h4>
          <pre><code class="example">var xmlDocument = [create xml document];
 $.ajax({
   url: "page.php",
   processData: false,
   data: xmlDocument,
   success: handleResponse
 });</code></pre>
        </div>
        <div id="example-5">
          <h4>Example: <span class="desc">作为发送数据到服务器的ID，保存一些数据到服务器，并通知用户一旦它的完成。请注意，此用法 - 返回到一个变量的调用的结果 - 需要同步（阻塞）的要求！ （异步：假）</span> </h4>
          <pre><code class="example">bodyContent = $.ajax({
      url: "script.php",
      global: false,
      type: "POST",
      data: ({id : this.getAttribute('id')}),
      dataType: "html",
      async:false,
      success: function(msg){
         alert(msg);
      }
   }
).responseText;</code></pre>
        </div>
      </div>
    </div>
  </div>
</div>
<div class="copy"><a href="http://julying.com/jQuery-1.6-api/" title="jQuery 1.6 API 中文版">jQuery 1.6 API 中文版</a>由<a href="http://julying.com/" target="_blank" title="前端攻城师">前端攻城师</a>整理、修订 (2011年6月)</div></body>
</html>