<!DOCTYPE html>
<html lang='en'><head><meta http-equiv='content-type' content='text/html; charset=UTF-8' /><title>jQuery 1.6  API 中文版 -- 前端攻城师</title></head><body>
<div class="entry-content">
        <div class="entry-title roundTop">
          
          <h1 class="jq-clearfix">jQuery.when()</h1>
          <div class="entry-meta jq-clearfix">
                        Categories:
            <span class="category"><a   target="_blank" href="http://api.jquery.com/category/core/" title="View all posts in Core">Core</a></span>
  

          </div>

</div>
<div id="jQuery-when1" class="entry method">
<h2 class="jq-clearfix roundTop section-title">
<span class="name">jQuery.when( deferreds )</span> <span class="returns">返回： <a class="return"   target="_blank" href="http://api.jquery.com/Types/#Deferred">Deferred</a></span>
</h2>
<div class="jq-box roundBottom entry-details">
<p class="desc"><strong>描述： </strong>提供一种方法来执行一个或多个对象的回调函数，延迟对象通常表示异步事件。</p>
<ul class="signatures"><li class="signature" id="jQuery-when-deferreds">
<h4 class="name">
<span class="versionAdded">version added: <a href="/category/version/1.5/">1.5</a></span>jQuery.when( deferreds )</h4>
<p class="arguement"><strong>deferreds</strong>一个或多个延迟对象，或者普通的JavaScript对象。</p>
</li></ul>
<div class="longdesc">
<p>如果单一延迟传递给<code>jQuery.when</code> ，它是通过这个方法和延迟对象附加的其他方法可访问绑定的回调函数返回的，如<code><a href="#p=deferred.then">defered.then</a></code> 。当延迟得到解决或者拒绝，通常的代码创建了原来的延迟，适当的回调将被调用。例如，jqXHR对象返回<code>jQuery.ajax</code>是一个延期，可以用这种方式：</p>
<pre>$.when( $.ajax("test.aspx") ).then(function(ajaxArgs){ 
     alert(ajaxArgs[1]); /* ajaxArgs is [ "success", statusText, jqXHR ] */
});</pre>
<p>如果一个参数被传递给<code>jQuery.when</code> ，这不是延迟，这将被视为延迟解决，并立即将执行附加任何doneCallbacks。该doneCallbacks传递原始的参数。在这种情况下，任何failCallbacks您可能会设置是永远不会被调用，因为延迟从不拒绝。例如：</p>
<pre>$.when( { testing: 123 } ).done(
   function(x){ alert(x.testing); } /* alerts "123" */
);</pre>
<p>在案例中有多个延迟对象传递<code>jQuery.when</code> ，该方法返回一个新的“宿主”延迟对象，跟踪所有已通过Deferreds聚集状态。该方法能够解决它的“宿主”延迟尽快解决所有延迟，或拒绝尽快将被拒绝的延迟。如果“宿主”延迟得到解决，它是通过传递给解析值，所有的延迟 <code>jQuery.when</code> 。例如，当延迟是<code>jQuery.ajax()</code>请求，参数将是jqXHR对象的要求，以便他们在名单内的说法。</p>
<p>在多延迟情况下，如果延迟一被拒绝，<code>jQuery.when</code>火灾立即掌握其推迟failCallbacks。请注意，延迟一些可能仍然在这一点没有得到解决。如果您需要执行额外的处理对于这种情况，如取消任何未完成的Ajax请求，你可以保持基本jqXHR引用对象在封闭和检查/取消在failCallback他们。</p>
</div>
<h3>Examples:</h3>
<div class="entry-examples" id="entry-examples">
<div id="example-0">
<h4>Example: <span class="desc">执行Ajax请求后两个函数是成功的。（见jQuery.ajax()对于一个成功的和错误的案件为AJAX请求的完整描述文档）。</span>
</h4>
<pre><code class="example">$.when($.ajax("/page1.php"), $.ajax("/page2.php")).done(function(a1,  a2){
    /* a1 and a2 are arguments resolved for the 
        page1 and page2 ajax requests, respectively */
   var jqXHR = a1[2]; /* arguments are [ "success", statusText, jqXHR ] */
   if ( /Whip It/.test(jqXHR.responseText) ) {
      alert("First page has 'Whip It' somewhere.");
   }
});
</code></pre>
</div>
<div id="example-1">
<h4>Example: <span class="desc">执行函数myfunc当两个Ajax请求是成功的，如果任一或myFailure有一个错误。
</span>
</h4>
<pre><code class="example">$.when($.ajax("/page1.php"), $.ajax("/page2.php"))
  .then(myFunc, myFailure);
</code></pre>
</div>
</div>
</div>
</div>

        </div>

<div class="copy"><a href="http://julying.com/jQuery-1.6-api/" title="jQuery 1.6 API 中文版">jQuery 1.6 API 中文版</a>由<a href="http://julying.com/" target="_blank" title="前端攻城师">前端攻城师</a>整理、修订 (2011年6月)</div></body></html>